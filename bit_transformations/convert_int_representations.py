# Intervalos com valores (alguns contendo None)
intervalos = [
    (1,1,1),
    (2,3,3),
    (4,7,7),
    (8,8,15),
    (16,21,31),
    (32,49,63),
    (64,76,127),
    (128,224,255),
    (256,467,511),
    (512,514,1023),
    (1024,1155,2047),
    (2048,2683,4095),
    (4096,5216,8191),
    (8192,10544,16383),
    (16384,26867,32767),
    (32768,51510,65535),
    (65536,95823,131071),
    (131072,198669,262143),
    (262144,357535,524287),
    (524288,863317,1048575),
    (1048576,1811764,2097151),
    (2097152,3007503,4194303),
    (4194304,5598802,8388607),
    (8388608,14428676,16777215),
    (16777216,33185509,33554431),
    (33554432,54538862,67108863),
    (67108864,111949941,134217727),
    (134217728,227634408,268435455),
    (268435456,400708894,536870911),
    (536870912,1033162084,1073741823),
    (1073741824,2102388551,2147483647),
    (2147483648,3093472814,4294967295),
    (4294967296,7137437912,8589934591),
    (8589934592,14133072157,17179869183),
    (17179869184,20112871792,34359738367),
    (34359738368,42387769980,68719476735),
    (68719476736,100251560595,137438953471),
    (137438953472,146971536592,274877906943),
    (274877906944,323724968937,549755813887),
    (549755813888,1003651412950,1099511627775),
    (1099511627776,1458252205147,2199023255551),
    (2199023255552,2895374552463,4398046511103),
    (4398046511104,7409811047825,8796093022207),
    (8796093022208,15404761757071,17592186044415),
    (17592186044416,19996463086597,35184372088831),
    (35184372088832,51408670348612,70368744177663),
    (70368744177664,119666659114170,140737488355327),
    (140737488355328,191206974700443,281474976710655),
    (281474976710656,409118905032525,562949953421311),
    (562949953421312,611140496167764,1125899906842623),
    (1125899906842624,2058769515153876,2251799813685247),
    (2251799813685248,4216495639600700,4503599627370495),
    (4503599627370496,6763683971478124,9007199254740991),
    (9007199254740992,9974455244496708,18014398509481984),
    (18014398509481984,30045390491869460,36028797018963968),
    (36028797018963968,44218742292676576,72057594037927936),
    (72057594037927936,138245758910846496,144115188075855872),
    (144115188075855872,199976667976342048,288230376151711744),
    (288230376151711744,525070384258266176,576460752303423488),
    (576460752303423488,1135041350219496320,1152921504606846976),
    (1152921504606846976,1425787542618654976,2305843009213693952),
    (2305843009213693952,3908372542507822080,4611686018427387904),
    (4611686018427387904,8993229949524469760,9223372036854775808),
    (9223372036854775808,17799667357578235904,18446744073709551616),
    (18446744073709551616,30568377312064204800,36893488147419103232),
    (36893488147419103232,46346217550346338304,73786976294838206464),
    (73786976294838206464,132656943602386255872,147573952589676412928),
    (147573952589676412928,219898266213316034560,295147905179352825856),
    (295147905179352825856,297274491920375873536,590295810358705651712),
    (590295810358705651712,970436974005023670272,1180591620717411303424),
    (1180591620717411303424,None,2361183241434822606848),
    (2361183241434822606848,None,4722366482869645213696),
    (4722366482869645213696,None,9444732965739290427392),
    (9444732965739290427392,None,18889465931478580854784),
    (18889465931478580854784,22538323240989824647168,37778931862957161709568),
    (37778931862957161709568,None,75557863725914323419136),
    (75557863725914323419136,None,151115727451828646838272),
    (151115727451828646838272,None,302231454903657293676544),
    (302231454903657293676544,None,604462909807314587353088),
    (604462909807314587353088,1105520030589234431655936,1208925819614629174706176),
    (1208925819614629174706176,None,2417851639229258349412352),
    (2417851639229258349412352,None,4835703278458516698824704),
    (4835703278458516698824704,None,9671406556917033397649408),
    (9671406556917033397649408,None,19342813113834066795298816),
    (19342813113834066795298816,21090315766411507338838016,38685626227668133590597632),
    (38685626227668133590597632,None,77371252455336267181195264),
    (77371252455336267181195264,None,154742504910672534362390528),
    (154742504910672534362390528,None,309485009821345068724781056),
    (309485009821345068724781056,None,618970019642690137449562112),
    (618970019642690137449562112,868012190417726377904046080,1237940039285380274899124224),
    (1237940039285380274899124224,None,2475880078570760549798248448),
    (2475880078570760549798248448,None,4951760157141521099596496896),
    (4951760157141521099596496896,None,9903520314283042199192993792),
    (9903520314283042199192993792,None,19807040628566084398385987584),
    (19807040628566084398385987584,25525831956644114284329041920,39614081257132168796771975168),
    (39614081257132168796771975168,None,79228162514264337593543950336),
    (79228162514264337593543950336,None,158456325028528675187087900672),
    (158456325028528675187087900672,None,316912650057057350374175801344),
    (316912650057057350374175801344,None,633825300114114700748351602688),
    (633825300114114700748351602688,868221233689326482094685159424,1267650600228229401496703205376),
    (1267650600228229401496703205376,None,2535301200456458802993406410752),
    (2535301200456458802993406410752,None,5070602400912917605986812821504),
    (5070602400912917605986812821504,None,10141204801825835211973625643008),
    (10141204801825835211973625643008,None,20282409603651670423947251286016),
    (20282409603651670423947251286016,29083230144918043474352194715648,40564819207303340847894502572032),
    (40564819207303340847894502572032,None,81129638414606681695789005144064),
    (81129638414606681695789005144064,None,162259276829213363391578010288128),
    (162259276829213363391578010288128,None,324518553658426726783156020576256),
    (324518553658426726783156020576256,None,649037107316853453566312041152512),
    (649037107316853453566312041152512,1090246098153987122742007059972096,1298074214633706907132624082305024),
    (1298074214633706907132624082305024,None,2596148429267413814265248164610048),
    (2596148429267413814265248164610048,None,5192296858534827628530496329220096),
    (5192296858534827628530496329220096,None,10384593717069655257060992658440192),
    (10384593717069655257060992658440192,None,20769187434139310514121985316880384),
    (20769187434139310514121985316880384,31464123230573853396965426819235840,41538374868278621028243970633760768),
    (41538374868278621028243970633760768,None,83076749736557242056487941267521536),
    (83076749736557242056487941267521536,None,166153499473114484112975882535043072),
    (166153499473114484112975882535043072,None,332306998946228968225951765070086144),
    (332306998946228968225951765070086144,None,664613997892457936451903530140172288),
    (664613997892457936451903530140172288,919343500840980287176338231525376000,1329227995784915872903807060280344576),
    (1329227995784915872903807060280344576,None,2658455991569831745807614120560689152),
    (2658455991569831745807614120560689152,None,5316911983139663491615228241121378304),
    (5316911983139663491615228241121378304,None,10633823966279326983230456482242756608),
    (10633823966279326983230456482242756608,None,21267647932558653966460912964485513216),
    (21267647932558653966460912964485513216,37650549717742543066237230173355245568,42535295865117307932921825928971026432),
    (42535295865117307932921825928971026432,None,85070591730234615865843651857942052864),
    (85070591730234615865843651857942052864,None,170141183460469231731687303715884105728),
    (170141183460469231731687303715884105728,None,340282366920938463463374607431768211456),
    (340282366920938463463374607431768211456,None,680564733841876926926749214863536422912),
    (680564733841876926926749214863536422912,1103873984953507513725582045078716678144,1361129467683753853853498429727072845824),
    (1361129467683753853853498429727072845824,None,2722258935367507707706996859454145691648),
    (2722258935367507707706996859454145691648,None,5444517870735015415413993718908291383296),
    (5444517870735015415413993718908291383296,None,10889035741470030830827987437816582766592),
    (10889035741470030830827987437816582766592,None,21778071482940061661655974875633165533184),
    (21778071482940061661655974875633165533184,None,43556142965880123323311949751266331066368),
    (43556142965880123323311949751266331066368,None,87112285931760246646623899502532662132736),
    (87112285931760246646623899502532662132736,None,174224571863520493293247799005065324265472),
    (174224571863520493293247799005065324265472,None,348449143727040986586495598010130648530944),
    (348449143727040986586495598010130648530944,None,696898287454081973172991196020261297061888),
    (696898287454081973172991196020261297061888,None,1393796574908163946345982392040522594123776),
    (1393796574908163946345982392040522594123776,None,2787593149816327892691964784081045188247552),
    (2787593149816327892691964784081045188247552,None,5575186299632655785383929568162090376495104),
    (5575186299632655785383929568162090376495104,None,11150372599265311570767859136324180752990208),
    (11150372599265311570767859136324180752990208,None,22300745198530623141535718272648361505980416),
    (22300745198530623141535718272648361505980416,None,44601490397061246283071436545296723011960832),
    (44601490397061246283071436545296723011960832,None,89202980794122492566142873090593446023921664),
    (89202980794122492566142873090593446023921664,None,178405961588244985132285746181186892047843328),
    (178405961588244985132285746181186892047843328,None,356811923176489970264571492362373784095686656),
    (356811923176489970264571492362373784095686656,None,713623846352979940529142984724747568191373312),
    (713623846352979940529142984724747568191373312,None,1427247692705959881058285969449495136382746624),
    (1427247692705959881058285969449495136382746624,None,2854495385411919762116571938898990272765493248),
    (2854495385411919762116571938898990272765493248,None,5708990770823839524233143877797980545530986496),
    (5708990770823839524233143877797980545530986496,None,11417981541647679048466287755595961091061972992),
    (11417981541647679048466287755595961091061972992,None,22835963083295358096932575511191922182123945984),
    (22835963083295358096932575511191922182123945984,None,45671926166590716193865151022383844364247891968),
    (45671926166590716193865151022383844364247891968,None,91343852333181432387730302044767688728495783936),
    (91343852333181432387730302044767688728495783936,None,182687704666362864775460604089535377456991567872),
    (182687704666362864775460604089535377456991567872,None,365375409332725729550921208179070754913983135744),
    (365375409332725729550921208179070754913983135744,None,730750818665451459101842416358141509827966271488),
    (730750818665451459101842416358141509827966271488,None,1461501637330902918203684832716283019655932542976),

]

import csv
import base64
import hashlib
import uuid
import zlib
from numpy import linspace
import io
import pandas as pd
import struct

def to_key32(n):
    b = n.to_bytes(32, 'big', signed=False)
    return [f"{byte:02X}" for byte in b]
    
def to_m256(n):
    # pega 32 bytes (256 bits), transforma em 8 floats 32 bits cada
    b = n.to_bytes(32, 'big', signed=False)
    floats = struct.unpack('>8f', b)
    return list(floats)

def to_m256d(n):
    # pega 32 bytes (256 bits), transforma em 4 doubles 64 bits cada
    b = n.to_bytes(32, 'big', signed=False)
    doubles = struct.unpack('>4d', b)
    return list(doubles)

def to_m256i(n):
    # pega 32 bytes (256 bits), transforma em 8 ints 32 bits cada
    b = n.to_bytes(32, 'big', signed=False)
    ints = struct.unpack('>8I', b)
    return list(ints)
    
def to_dpd(n):
    digits = str(n)
    # para simplificar, converte cada grupo de 3 dígitos em um inteiro (0-999)
    dpd_list = []
    while digits:
        group = digits[-3:]
        digits = digits[:-3]
        dpd_list.insert(0, int(group))
    return dpd_list
# Funções de conversão
def to_decimal(n): return int(n)
def to_bin_vector(n): return [int(b) for b in bin(n)[2:].zfill(256)]
def to_bin_str(n): return bin(n)[2:]
def to_hex_vector(n): return [int(bin(n)[2:].zfill(256)[i:i+8], 2) for i in range(0, 256, 8)]
def to_hex_str(n): return hex(n)[2:].upper()
def to_little_endian_hex(n):
    h = hex(n)[2:].zfill(64)
    return [int(h[i:i+2], 16) for i in range(len(h)-2, -2, -2)]
def to_ascii_padded(n): return [ord(c) for c in str(n).rjust(8, "0")]
def to_utf8_bytes(n): return list(str(n).encode())
def to_base64(n): return base64.b64encode(str(n).encode()).decode()
def to_base32(n): return base64.b32encode(str(n).encode()).decode()
def to_base16(n): return base64.b16encode(str(n).encode()).decode()
def to_bcd(n):
    digits = str(n)
    if len(digits) % 2 != 0:
        digits = '0' + digits
    return [(int(digits[i]) << 4) + int(digits[i+1]) for i in range(0, len(digits), 2)]
def to_bcd_compact(n): return to_bcd(n)
def to_base256_bytes(n):
    b = []
    while n > 0:
        b.insert(0, n % 256)
        n //= 256
    return b
def to_vlq(n):
    vlq = []
    while True:
        byte = n & 0x7F
        n >>= 7
        if n:
            vlq.append(byte | 0x80)
        else:
            vlq.append(byte)
            break
    return vlq
def to_elias_gamma(n):
    binary = bin(n)[2:]
    return '0' * (len(binary) - 1) + binary
def to_gray_code(n): return bin(n ^ (n >> 1))[2:]
def to_sha1(n): return list(hashlib.sha1(str(n).encode()).digest())
def to_sha256(n): return list(hashlib.sha256(str(n).encode()).digest())
def to_sha512(n): return list(hashlib.sha512(str(n).encode()).digest())
def to_md5(n): return list(hashlib.md5(str(n).encode()).digest())
def to_crc32_bytes(n):
    crc = zlib.crc32(str(n).encode())
    return [(crc >> 24) & 0xFF, (crc >> 16) & 0xFF, (crc >> 8) & 0xFF, crc & 0xFF]
def to_crc32_decimal(n): return zlib.crc32(str(n).encode())
def to_crc32_hex(n): return f"{zlib.crc32(str(n).encode()):08X}"
def to_uuid_v5(n): return str(uuid.uuid5(uuid.NAMESPACE_DNS, str(n)))

def int_to_base(n, base, alphabet=None):
    if n == 0:
        return '0'
    if alphabet is None:
        # Default alphabet para até base 62
        alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'
    if base > len(alphabet):
        raise ValueError("Base maior que tamanho do alfabeto")
    digits = []
    while n > 0:
        digits.append(alphabet[n % base])
        n //= base
    digits.reverse()
    return ''.join(digits)

# Bases adicionais:

def to_base3(n): return int_to_base(n, 3)
def to_base5(n): return int_to_base(n, 5)
def to_base7(n): return int_to_base(n, 7)
def to_base9(n): return int_to_base(n, 9)
def to_base20(n): return int_to_base(n, 20)
def to_base36(n): return int_to_base(n, 36)

def to_base58(n):
    # Alfabeto Base58 comum (Bitcoin)
    alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
    return int_to_base(n, 58, alphabet)
    
def to_base62(n):
    # Dígitos + letras maiúsculas + minúsculas
    alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'
    return int_to_base(n, 62, alphabet)
    
def to_sparse_binary_vector(n):
    bits = bin(n)[2:].zfill(256)
    return [i for i, bit in enumerate(bits[::-1]) if bit == '1']
    
def to_powers_of_10(n):
    digits = list(str(n))
    powers = []
    for i, d in enumerate(digits):
        if d != '0':
            power = 10 ** (len(digits) - i - 1)
            powers.append(int(d) * power)
    return powers

def to_bloom_filter(n, size=256):
    hash1 = hashlib.md5(str(n).encode()).hexdigest()
    hash2 = hashlib.sha1(str(n).encode()).hexdigest()
    hash3 = hashlib.sha256(str(n).encode()).hexdigest()

    indices = [
        int(hash1, 16) % size,
        int(hash2, 16) % size,
        int(hash3, 16) % size,
    ]

    bloom = [0] * size
    for idx in indices:
        bloom[idx] = 1
    return bloom
    
def to_aes256_key(n):
    b = n.to_bytes(32, 'big', signed=False)
    return [f"{x:02X}" for x in b]

def to_multiplication_constants(n):
    return [n * i for i in range(1, 9)]

import math
def to_decimal_conversion_vector(n):
    count = int(math.log10(n)) + 1 if n > 0 else 1
    return [10.0 ** i for i in range(count)]
    
def to_font_bitmap_vector(n):
    digit_bitmaps = {
        '0': [0b00111100,0b01000010,0b01000110,0b01001010,0b01010010,0b01100010,0b01000010,0b00111100],
        '1': [0b00001000,0b00011000,0b00101000,0b00001000,0b00001000,0b00001000,0b00001000,0b00111110],
        '2': [0b00111100,0b01000010,0b00000010,0b00000100,0b00001000,0b00010000,0b00100000,0b01111110],
        '3': [0b00111100,0b01000010,0b00000010,0b00011100,0b00000010,0b00000010,0b01000010,0b00111100],
        '4': [0b00000100,0b00001100,0b00010100,0b00100100,0b01000100,0b01111110,0b00000100,0b00000100],
        '5': [0b01111110,0b01000000,0b01000000,0b01111100,0b00000010,0b00000010,0b01000010,0b00111100],
        '6': [0b00111100,0b01000010,0b01000000,0b01111100,0b01000010,0b01000010,0b01000010,0b00111100],
        '7': [0b01111110,0b00000010,0b00000100,0b00001000,0b00010000,0b00010000,0b00010000,0b00010000],
        '8': [0b00111100,0b01000010,0b01000010,0b00111100,0b01000010,0b01000010,0b01000010,0b00111100],
        '9': [0b00111100,0b01000010,0b01000010,0b00111110,0b00000010,0b00000010,0b01000010,0b00111100],
    }
    bitmaps = []
    for d in str(n):
        if d in digit_bitmaps:
            bitmaps.extend(digit_bitmaps[d])
    return bitmaps


def to_pbkdf2(n, salt=b'somesalt', iterations=10000, dklen=32):
    # n é tratado como string para derivar a key
    key = hashlib.pbkdf2_hmac('sha256', str(n).encode(), salt, iterations, dklen)
    return [f"{b:02X}" for b in key]

def to_fibonacci_encoding(n):
    # Lista de números de Fibonacci até n
    fib = [1, 2]
    while fib[-1] <= n:
        fib.append(fib[-2] + fib[-1])
    fib.pop()  # remove o primeiro maior que n
    
    code = []
    remaining = n
    for f in reversed(fib):
        if f <= remaining:
            code.append('1')
            remaining -= f
        else:
            code.append('0')
    code.append('1')  # Terminador adicional para codificação Fibonacci
    return ''.join(code)
    
def to_elias_delta(n):
    if n == 0:
        return '0'
    import math
    
    def elias_gamma(x):
        b = bin(x)[2:]
        return '0' * (len(b) - 1) + b

    b = bin(n)[2:]
    length = len(b)
    gamma_len = elias_gamma(length)
    offset = b[1:]  # remove o bit mais significativo
    return gamma_len + offset
def to_aes256_key_from_n(n):
    b = n.to_bytes(32, 'big', signed=False)
    return [f"{x:02X}" for x in b]

def to_aes_iv_from_n(n):
    # IV de 16 bytes (128 bits) — usa os últimos 16 bytes de n (ou zero paddings)
    b = n.to_bytes(32, 'big', signed=False)
    iv = b[-16:]
    return [f"{x:02X}" for x in iv]
def to_blake2b_256(n):
    h = hashlib.blake2b(str(n).encode(), digest_size=32).digest()
    return [f"{b:02X}" for b in h]

def to_blake3_256(n):
    import blake3
    h = blake3.blake3(str(n).encode()).digest()
    return [f"{b:02X}" for b in h[:32]]

# Conversores
converters = {
    "Decimal": to_decimal,
    "Binário (string)": to_bin_str,
    "Binário (vetor)": to_bin_vector,
    "Hex string": to_hex_str,
    "Hex vetor": to_hex_vector,
    "Little Endian": to_little_endian_hex,
    "ASCII padded": to_ascii_padded,
    "UTF-8 bytes": to_utf8_bytes,
    "Base 3": to_base3,
    "Base 5": to_base5,
    "Base 7": to_base7,
    "Base 9": to_base9,
    "Base16": to_base16,
    "Base 20": to_base20,
    "Base32": to_base32,
    "Base 36": to_base36,
    "Base 58": to_base58,
    "Base 62": to_base62,
    "Base64": to_base64,
    "BCD": to_bcd,
    "BCD Compactado": to_bcd_compact,
    "Base256": to_base256_bytes,
    "VLQ": to_vlq,
    "Elias Gamma": to_elias_gamma,
    "Gray Code": to_gray_code,
    "SHA-1": to_sha1,
    "SHA-256": to_sha256,
    "SHA-512": to_sha512,
    "MD5": to_md5,
    "CRC32 (bytes)": to_crc32_bytes,
    "CRC32 (decimal)": to_crc32_decimal,
    "CRC32 (hex)": to_crc32_hex,
    "UUIDv5": to_uuid_v5,
    "__m256 (float32 vetor)": to_m256,
    "__m256d (double64 vetor)": to_m256d,
    "__m256i (int32 vetor)": to_m256i,
    "Chave Criptográfica (32 bytes)": to_key32,
    "Decimal128 (string utf-8)": lambda n: list(str(n).encode()),
    "Densely Packed Decimal (simplificado)": to_dpd,
    "PBKDF2 (SHA-256, 10k iterações)": to_pbkdf2,
    "Fibonacci Encoding": to_fibonacci_encoding,
    "Elias Delta Coding": to_elias_delta,
    "AES-256 Key": to_aes256_key_from_n,
    "AES-128 IV": to_aes_iv_from_n,
    "Blake2b-256": to_blake2b_256,
    "Blake3-256": to_blake3_256,
}

def gerar_valores(ini, fim, meio, num=5):
    # Gera valores uniformemente espaçados
    valores = [ini + i * ((fim - ini) // (num - 1)) for i in range(num)]
    
    # Garante que o meio esteja presente se for válido e distinto
    if meio is not None and ini <= meio <= fim and meio not in valores:
        valores.append(meio)
    
    # Remove duplicatas e ordena
    return sorted(set(valores))

with open("todos_os_vetores.csv", "w", newline="", encoding="utf-8") as f:
    writer = csv.writer(f, delimiter=';')
    writer.writerow(["Valor"] + list(converters.keys()) + ["Meio"])

    for ini, meio, fim in intervalos:
        if ini > fim:
            continue  # pular intervalos inválidos

        valores = gerar_valores(ini, fim, meio, num=5)

        for val in valores:
            row = [f"'{val}'"]
            for k in converters:
                try:
                    result = converters[k](val)
                    result_str = '[' + ','.join(map(str, result)) + ']' if isinstance(result, list) else str(result)
                    row.append(f"'{result_str}'")
                except Exception as e:
                    row.append(f"'Erro: {e}'")

            # Marcar se esse valor é o meio
            meio_info = "'Sim'" if val == meio else "''"
            row.append(meio_info)
            writer.writerow(row)

print("✅ Arquivo CSV gerado com sucesso: todos_os_vetores.csv")
