# Lista de tuplas (TARGET_LEN como int, Address como str)
data_address = [
 (71, '1PWo3JeB9jrGwfHDNpdGK54CRas7fsVzXU'),    (72, '1JTK7s9YVYywfm5XUH7RNhHJH1LshCaRFR'),
    (73, '12VVRNPi4SJqUTsp6FmqDqY5sGosDtysn4'),    (74, '1FWGcVDK3JGzCC3WtkYetULPszMaK2Jksv'),
    (75, '1J36UjUByGroXcCvmj13U6uwaVv9caEeAt'),    (76, '1DJh2eHFYQfACPmrvpyWc8MSTYKh7w9eRF'),
    (77, '1Bxk4CQdqL9p22JEtDfdXMsng1XacifUtE'),    (78, '15qF6X51huDjqTmF9BJgxXdt1xcj46Jmhb'),
    (79, '1ARk8HWJMn8js8tQmGUJeQHjSE7KRkn2t8'),    (80, '1BCf6rHUW6m3iH2ptsvnjgLruAiPQQepLe'),    (81, '15qsCm78whspNQFydGJQk5rexzxTQopnHZ'),    (82, '13zYrYhhJxp6Ui1VV7pqa5WDhNWM45ARAC'),
    (83, '14MdEb4eFcT3MVG5sPFG4jGLuHJSnt1Dk2'),    (84, '1CMq3SvFcVEcpLMuuH8PUcNiqsK1oicG2D'),    (85, '1Kh22PvXERd2xpTQk3ur6pPEqFeckCJfAr'),
    (86, '1K3x5L6G57Y494fDqBfrojD28UJv4s5JcK'),    (87, '1PxH3K1Shdjb7gSEoTX7UPDZ6SH4qGPrvq'),
    (88, '16AbnZjZZipwHMkYKBSfswGWKDmXHjEpSf'),    (89, '19QciEHbGVNY4hrhfKXmcBBCrJSBZ6TaVt'),
    (90, '1L12FHH2FHjvTviyanuiFVfmzCy46RRATU'),    (91, '1EzVHtmbN4fs4MiNk3ppEnKKhsmXYJ4s74'),
    (92, '1AE8NzzgKE7Yhz7BWtAcAAxiFMbPo82NB5'),    (93, '17Q7tuG2JwFFU9rXVj3uZqRtioH3mx2Jad'),    (94, '1K6xGMUbs6ZTXBnhw1pippqwK6wjBWtNpL'),    (95, '19eVSDuizydXxhohGh8Ki9WY9KsHdSwoQC'),
    (96, '15ANYzzCp5BFHcCnVFzXqyibpzgPLWaD8b'),    (97, '18ywPwj39nGjqBrQJSzZVq2izR12MDpDr8'),    (98, '1CaBVPrwUxbQYYswu32w7Mj4HR4maNoJSX'),    (99, '1JWnE6p6UN7ZJBN7TtcbNDoRcjFtuDWoNL'),
    (100, '1KCgMv8fo2TPBpddVi9jqmMmcne9uSNJ5F'),    (101, '1CKCVdbDJasYmhswB6HKZHEAnNaDpK7W4n'),    (102, '1PXv28YxmYMaB8zxrKeZBW8dt2HK7RkRPX'),    (103, '1AcAmB6jmtU6AiEcXkmiNE9TNVPsj9DULf'),
    (104, '1EQJvpsmhazYCcKX5Au6AZmZKRnzarMVZu'),    (105, '1CMjscKB3QW7SDyQ4c3C3DEUHiHRhiZVib'),    (106, '18KsfuHuzQaBTNLASyj15hy4LuqPUo1FNB'),
    (107, '15EJFC5ZTs9nhsdvSUeBXjLAuYq3SWaxTc'),    (108, '1HB1iKUqeffnVsvQsbpC6dNi1XKbyNuqao'),    (109, '1GvgAXVCbA8FBjXfWiAms4ytFeJcKsoyhL'),
    (110, '12JzYkkN76xkwvcPT6AWKZtGX6w2LAgsJg'),    (111, '1824ZJQ7nKJ9QFTRBqn7z7dHV5EGpzUpH3'),
    (112, '18A7NA9FTsnJxWgkoFfPAFbQzuQxpRtCos'),    (113, '1NeGn21dUDDeqFQ63xb2SpgUuXuBLA4WT4'),
    (114, '174SNxfqpdMGYy5YQcfLbSTK3MRNZEePoy'),    (115, '1NLbHuJebVwUZ1XqDjsAyfTRUPwDQbemfv'),    (116, '1MnJ6hdhvK37VLmqcdEwqC3iFxyWH2PHUV'),
    (117, '1KNRfGWw7Q9Rmwsc6NT5zsdvEb9M2Wkj5Z'),    (118, '1PJZPzvGX19a7twf5HyD2VvNiPdHLzm9F6'),
    (119, '1GuBBhf61rnvRe4K8zu8vdQB3kHzwFqSy7'),    (120, '17s2b9ksz5y7abUm92cHwG8jEPCzK3dLnT'),
    (121, '1GDSuiThEV64c166LUFC9uDcVdGjqkxKyh'),    (122, '1Me3ASYt5JCTAK2XaC32RMeH34PdprrfDx'),    (123, '1CdufMQL892A69KXgv6UNBD17ywWqYpKut'),
    (124, '1BkkGsX9ZM6iwL3zbqs7HWBV7SvosR6m8N'),    (125, '1PXAyUB8ZoH3WD8n5zoAthYjN15yN5CVq5'),    (126, '1AWCLZAjKbV1P7AHvaPNCKiB7ZWVDMxFiz'),    (127, '1G6EFyBRU86sThN3SSt3GrHu1sA7w7nzi4'),    (128, '1MZ2L1gFrCtkkn6DnTT2e4PFUTHw9gNwaj'),
    (129, '1Hz3uv3nNZzBVMXLGadCucgjiCs5W9vaGz'),    (130, '1Fo65aKq8s8iquMt6weF1rku1moWVEd5Ua'),    (131, '16zRPnT8znwq42q7XeMkZUhb1bKqgRogyy'),
    (132, '1KrU4dHE5WrW8rhWDsTRjR21r8t3dsrS3R'),    (133, '17uDfp5r4n441xkgLFmhNoSW1KWp6xVLD'),    (134, '13A3JrvXmvg5w9XGvyyR4JEJqiLz8ZySY3'),
    (135, '16RGFo6hjq9ym6Pj7N5H7L1NR1rVPJyw2v'),    (136, '1UDHPdovvR985NrWSkdWQDEQ1xuRiTALq'),
    (137, '15nf31J46iLuK1ZkTnqHo7WgN5cARFK3RA'),    (138, '1Ab4vzG6wEQBDNQM1B2bvUz4fqXXdFk2WT'),    (139, '1Fz63c775VV9fNyj25d9Xfw3YHE6sKCxbt'),
    (140, '1QKBaU6WAeycb3DbKbLBkX7vJiaS8r42Xo'),    (141, '1CD91Vm97mLQvXhrnoMChhJx4TP9MaQkJo'),    (142, '15MnK2jXPqTMURX4xC3h4mAZxyCcaWWEDD'),    (143, '13N66gCzWWHEZBxhVxG18P8wyjEWF9Yoi1'),
    (144, '1NevxKDYuDcCh1ZMMi6ftmWwGrZKC6j7Ux'),    (145, '19GpszRNUej5yYqxXoLnbZWKew3KdVLkXg'),    (146, '1M7ipcdYHey2Y5RZM34MBbpugghmjaV89P'),    (147, '18aNhurEAJsw6BAgtANpexk5ob1aGTwSeL'),
    (148, '1FwZXt6EpRT7Fkndzv6K4b4DFoT4trbMrV'),    (149, '1CXvTzR6qv8wJ7eprzUKeWxyGcHwDYP1i2'),    (150, '1MUJSJYtGPVGkBCTqGspnxyHahpt5Te8jy'),    (151, '13Q84TNNvgcL3HJiqQPvyBb9m4hxjS3jkV'),
    (152, '1LuUHyrQr8PKSvbcY1v1PiuGuqFjWpDumN'),    (153, '18192XpzzdDi2K11QVHR7td2HcPS6Qs5vg'),    (154, '1NgVmsCCJaKLzGyKLFJfVequnFW9ZvnMLN'),    (155, '1AoeP37TmHdFh8uN72fu9AqgtLrUwcv2wJ'),
    (156, '1FTpAbQa4h8trvhQXjXnmNhqdiGBd1oraE'),    (157, '14JHoRAdmJg3XR4RjMDh6Wed6ft6hzbQe9'),    (158, '19z6waranEf8CcP8FqNgdwUe1QRxvUNKBG'),    (159, '14u4nA5sugaswb6SZgn5av2vuChdMnD9E5'),
    (160, '1NBC8uXJy1GiJ6drkiZa1WuKn51ps7EPTv'),    (161, '1JkqBQcC4tHcb1JfdCH6nrWYwTPGznHANh'),    (162, '17DTUTXUcUYEgrr5GhivxYei4Lrs1xMnS2'),    (163, '1H6e7SLxv6ZUbuAaZpeUdVNfh3cKBWJRmx'),
    (164, '1LjQKurNtEDgMdqeCoWRFhHp1FPnLU77Q4'),    (165, '1F7ZjibYug9bLW3YvkkwBZLrhfLtNjgYrX'),    (166, '12BtvPaamiBCpXmoDrsCxAa1b6hMRnASZ4'),    (167, '1AvLwGpkwTZH4qiwy1L4v6TuWXLMNrATN5'),
    (168, '1PojqbbzJHnn1X2mv6DCECNLUaD2nMssDp'),    (169, '1G3uazv67BcKRmPFvgvX4ijBTa2898cvCm'),    (170, '1EW9W5sGdxVDxAtjRbCjgkZNtPH8ZzikeP'),    (171, '17zzMMnj5h8StLhnrXpw8iBP21uujNC4Ap'),
    (172, '15LJKhwQJ7dYMBZX1mktskZqxX1aUCibkr'),    (173, '1Mkodin3C3drVaV9JNk1o3i4n4gVGe9GVx'),    (174, '1C6dHU1gQtVUXZmeXQuQc3EgDJbiLbxFZJ'),    (175, '1DxZJy7AkqLVAQ5rtSUKfrR3yPE5u5ygk6'),
    (176, '1NcytLwdqJa8DsQPa9NwkxJTQcx1rZy85A'),    (177, '163vG9mKmAsrvmq42MBDPjf9axZyEgBc9R'),    (178, '12ATwA5VvoPDinSymcQpCAXPLApAVLN24z'),    (179, '12fXbBE7kTfqYk8dYyU9bw7XfKVwEqXnzg'),
    (180, '1EkYsB1C7deWxiVUULeZpr42AdYWhv4PEX'),    (181, '1MPQyhXBT2FpUMCiv5YX3yacKvmc9P5x6S'),    (182, '1GZyxmpgtRJNaW1zEhPAa81xZDEJSdwbbZ'),    (183, '12E2HWQVHzuGKAQVvPUkHWwibAJfnmcHW1'),
    (184, '14J1fXY2E3fbxjp1zpfqRhk5BNQ4pb97Rs'),    (185, '1HqHHuFzZhtTtyGbAWCS49qGnCBSEhBSFT'),    (186, '1BJXBDt4e1uaorXPototucUGNRme57nAqt'),    (187, '19ct7Egfi5j6jSefj8X4d5eXJQUmyhtXjC'),    
    (188, '1DyWSY1dA3wyjo4eMuQCPfrm3dV96xDDSU'),    (189, '1PiLrDyeXtncnsvcVAGGcNnpzQVRCG3fwS'),    (190, '1HUoYzoEn2a4WxKvnYYbnR9GKrVqAfq7oY'),
    (191, '19vnME8b28SzJDuEFNShAG5JCR63V1zzV'),    (192, '1GWTEv76C8cusq4h5gV3rLjeFhBkGBHSKg'),    (193, '1NHh2fQDm7KyBs8HRFkVtHgMzkmufk6mNW'),    (194, '1oW8VFRNVKhbzzq8NWNutDYDzv1CzAHAj'),    
    (195, '16q15tpaHQFUENUmRPLgiidCMWLcDpVEgs'),    (196, '1AH4d8Bss6eFyugZaN2qPXMBH69T946dSK'),
    (197, '12gDPuHvZBh6FSjyhHhyDDkM38Y2wyDGQt'),    (198, '12jFRwZFUrxUTtuyVzw9FNJsJa7mjBgfca'),
    (199, '1BNkFNU3eJz8jDfTkTwe7XmF18BfQwfqW7'),
    (200, '1DEDEKJVEmXvEqwg3wbq8c1ZNobo4tNw4h'),    (201, '1DA2RexqNkbVhzfkmQDHRMfKrdesgyMMdQ'),
    (202, '19Ho5YB6y8qRCdUMxWpXqrm8N4AKAq7ZWS'),    (203, '1DVWn7PuRBmsdTBKiboBdSREHdAtSoN6BB'),
    (204, '14CMU6qvv55Y7xJdVw64ey5yfUP4BZAjct'),
    (205, '1DHL5NuXPjwDsNnXyzAgZTAMM4aYUc1zFW'),
    (206, '1UwsEPMF1NZTWJAuymsLVJpqetBZ3Q9sJ'),    (207, '16aELF1f75o464ZhtAZUwbc4ctFQZxS8qi'),
    (208, '15TJ3wPvdviupvKQFm8hLeXSzeMSq7LSJ2'),    (209, '1JgrGoQbvJS7UnX6j4myiCxo6Q3gyo5Ujk'),
    (210, '14Xm5DjBUQTJCzeGhyrhVsxkK8p35srk1S'),    (211, '19yhSoza8oK3ioCSydMuAGJs4Mm3FwCTht'),
    (212, '1JXw9i8dEZGH29mUiuKjWXK9L27r2TerLQ'),    (213, '1CNNth43uiVypxHmZLC8hWZsb7UiP7wSkY'),
    (214, '16ocVeZDpqcvyMvzAH1r2LR75uEzRhkyV2'),    (215, '15x3tRVyn9SRaxfbFUzqETmCJiz46Vs247'),
    (216, '197K7MdYhnN88gcJouJRxMiSAHHfWuPrXC'),    (217, '1MDsNYfC4LErgwUDqfQ5BgFJqv5bs4Frkn'),
    (218, '1BDTXmiyyzq9i79RGGTW7cjmYJbxKoV27e'),    (219, '1EiJ59LPWDezXwfAGFTcoEKdNhvRTriBXy'),
    (220, '1rirV4Y2NxGwKNQNojJhz61jEctni8fvb'),    (221, '1NxgWntAdMugSNFHEXYizYwk3UjxKPxcDF'),
    (222, '17A75vEkPPVeY9MMMXUY9M2JUHbbNyVAWC'),    (223, '1NUVBXgX35Uax4fpziV7VGMJyji3mUzZbt'),
    (224, '1F6yxcbDzjumeN77DiABMXzPcvtAdnaoPF'),    (225, '16YvGEYhAwjf2duwvH8jbFMfVCnY6XiQTq'),
    (226, '1HtbZg9mPjYcMDMDNyXaFjHX5e7ZPUwWAp'),    (227, '15a9nXpjnQzw2o5kmvGyKzv7anZkYFHwdK'),
    (228, '18zsQK8ezT32qCqgLJQMkhqyKNwpCP3JU3'),    (229, '1AaBhpTnfCin9nCrai2msXzCHoVmwkAe2N'),
    (230, '13Jtm1mm33Uke7PbmTBYGNZGU7rXUsVs3e'),    (231, '18aBXRctVrWN9naDGhKrLdZViNfLJfCdbF'),
    (232, '1MEEjd99pkEyCdiqVSCa8Jqjaun7fsEXaG'),
    (233, '1NnefTEeKQQAts37cQHzVx8oPrUu8LWyUK'),
    (234, '1FYbLcutmRbvu4yUeLmC4TES2Q3ChhXYY'),    (235, '1Pp61TfkztZ9ckpdeUVCzbyA7vMqXAVsdV'),
    (236, '1PytbQzRaf9eTpGax3c6ofKwtbxaLLSNy1'),    (237, '194bRtNQVRq4xi26UJZYTHexvLXijpzp3e'),
    (238, '1DxBvzRMdvzop21DhnDJv4xJDYFGVtu7KZ'),    (239, '1QLHLvM6XKwygyWqo2cCPbfbf6woZzGEKH'),
    (240, '1C8Hw6T5jypz92cNFr9Lkx4Xmr4DtP7zGA'),    (241, '1L7ZNx5gFPvdVPfdgFBnEUgA64woQwopqr'),
    (242, '1EMhTbC4Kp8DYBk5zoLsTqZ2YakhiTgQYh'),    (243, '19CqmBBJ3H8FjxSSeSjv2Kn1cVQFXMY6AM'),
    (244, '1KMHDrCGho2QuK59UNvfjuiPdDZSgRbneC'),    (245, '1HzpmnHxpu4tCJ23ZS9TfWCoX8mXfpdHiq'),
    (246, '1LrrNP28PYg1N1z5Uo1gR8cmoPc8h4orBZ'),    (247, '14D2d3WnHThUxyPhGoj2AabBTxpZcoHy3t'),
    (248, '18oqrdP6uBKsn57gvmWzLuKMAY4ShapiAU'),    (249, '1Bun4VzuBJ7SUoQn97dinVfDyWAS336Ldg'),
    (250, '1Ruu3JwvGeSmhQV9GzWAnyLCz6g3evmTY'),    (251, '1M3u4q5Q35qtQPmDHeubVbk7APYi3VVoBX'),    (252, '1CaTxB3YwmXZkDnTK4rRvq61SRqs48xmui'),    (253, '1JqRqUPHHcQu2yrr8JZzxSYDx2jbZxEqFj'),    (254, '1NKkjFvXmovmjwgUujw655n3BbEvnncyza'),    (255, '17PEUvQmgqPkkvRkMowoR1wRDXYzre4b9Z'),    (256, '1FMcotmnqqE5M2x9DDX3VfPAPuBWArGisa'),
]

import random
import time
from deap import base, creator, tools
from bit import Key
from multiprocessing import Pool
import os
import psutil

try:
    p = psutil.Process(os.getpid())
    p.nice(psutil.IDLE_PRIORITY_CLASS)  # Define prioridade como "baixa"
    print("[INFO] Prioridade do processo ajustada para BAIXA.")
except Exception as e:
    print(f"[WARNING] Falha ao ajustar prioridade: {e}")
# Configurações
POPULATION_SIZE = random.randint(1, 10000)

P_CROSSOVER = 0.5 
P_MUTATION = round(random.uniform(0.01, 0.9), 4)

INDPB = 0.2
MAX_GENERATIONS = 140
TOUR_SIZE = 4

known_addresses = set()

def fitness_function(individual):
    secret = "".join(map(str, individual))
    if not secret:
        return (0,)
    number = int(secret, 2)
    if number <= 0:
        return (0,)
    try:
        addr = Key.from_int(number).address
    except Exception:
        return (0,)
    return (1,) if addr in known_addresses else (0,)

def get_best_info(ind, target):
    secret = "".join(map(str, ind))
    if not secret:
        return (0, "", "", "")
    try:
        number = int(secret, 2)
        if number <= 0:
            return (0, "", "", "")
    except ValueError:
        return (0, "", "", "")
    try:
        key = Key.from_int(number)
    except Exception:
        return (0, "", "", "")
    addr = key.address
    wif = key.to_wif()
    score = sum(a == b for a, b in zip(target, addr))
    return (score, addr, secret, wif)

def run_genetic(TARGET_LEN, data_address):
    global known_addresses

    if TARGET_LEN < 2:
        print(f"[!] TARGET_LEN={TARGET_LEN} é muito pequeno para cruzamento genético. Use pelo menos 2.")
        return

    filtered = [addr for l, addr in data_address if l == TARGET_LEN]
    if not filtered:
        print(f"[!] Nenhum endereço com TARGET_LEN = {TARGET_LEN}. Avançando...")
        return

    known_addresses = set(addr for _, addr in data_address)
    target = random.choice(filtered)
    print(f"\n== Iniciado TARGET_LEN={TARGET_LEN} – Target: {target}")

    if not hasattr(creator, "FitnessMax"):
        creator.create("FitnessMax", base.Fitness, weights=(1.0,))
    if not hasattr(creator, "Individual"):
        creator.create("Individual", list, fitness=creator.FitnessMax)

    toolbox = base.Toolbox()
    toolbox.register("attr_bool", random.randint, 0, 1)
    toolbox.register("individual", tools.initRepeat, creator.Individual, toolbox.attr_bool, TARGET_LEN)
    toolbox.register("population", tools.initRepeat, list, toolbox.individual)
    toolbox.register("evaluate", fitness_function)
    toolbox.register("select", tools.selTournament, tournsize=TOUR_SIZE)
    toolbox.register("mate", tools.cxTwoPoint)
    toolbox.register("mutate", tools.mutFlipBit, indpb=INDPB)

    population = toolbox.population(n=POPULATION_SIZE)

    with Pool() as pool:
        toolbox.register("map", pool.map)
        fitnesses = toolbox.map(toolbox.evaluate, population)
        for ind, fit in zip(population, fitnesses):
            ind.fitness.values = fit

        best = max(population, key=lambda ind: ind.fitness.values[0])
        max_fit = best.fitness.values[0]
        last_addr = None
        start = time.time()

        for gen in range(1, MAX_GENERATIONS + 1):
            offspring = toolbox.select(population, len(population))
            offspring = list(map(toolbox.clone, offspring))

            for c1, c2 in zip(offspring[::2], offspring[1::2]):
                if random.random() < P_CROSSOVER:
                    toolbox.mate(c1, c2)
                    del c1.fitness.values, c2.fitness.values

            for mutant in offspring:
                if random.random() < P_MUTATION:
                    toolbox.mutate(mutant)
                    del mutant.fitness.values

            invalid = [ind for ind in offspring if not ind.fitness.valid]
            fitnesses = toolbox.map(toolbox.evaluate, invalid)
            for ind, fit in zip(invalid, fitnesses):
                ind.fitness.values = fit

            population[:] = offspring
            current_max = max(ind.fitness.values[0] for ind in population)

            if current_max > max_fit:
                max_fit = current_max
                best = max(population, key=lambda ind: ind.fitness.values[0])

            score, addr, secret, wif = get_best_info(best, target)

            if not secret:  # segurança extra para evitar erro
                print("[!] Indivíduo inválido, ignorando iteração.", end="\r")
                
                continue

            if addr == last_addr:  
                number = int(secret, 2) 
                interval_start = 2 ** (TARGET_LEN - 1)
                interval_end = 2 ** TARGET_LEN - 1

                max_attempts = 10
                attempts = 0
                new_addr = addr

                while new_addr == last_addr and attempts < max_attempts:
                    percentual_de_pulo = round(random.uniform(1, 99), 6)
                    step = max(int((interval_end - interval_start) * percentual_de_pulo / 100), 1)

                    if number + step <= interval_end:
                        new_number = number + step
                    else:
                        new_number = max(number - step, interval_start)

                    bitstr = bin(new_number)[2:].zfill(TARGET_LEN)

                    if len(bitstr) != TARGET_LEN:
                        print("[!] bitstr length inconsistente, pulando tentativa.")
                        attempts += 1
                        continue

                    try:
                        key = Key.from_int(new_number)
                        new_addr = key.address

                        #print(f"[DEBUG] Tentativa {attempts+1}: percentual_de_pulo={percentual_de_pulo}, new_number={new_number}, new_addr={new_addr}")

                        if new_addr != last_addr:
                            addr = new_addr
                            wif = key.to_wif()
                            best = creator.Individual(list(map(int, bitstr)))
                            best.fitness.values = toolbox.evaluate(best)
                            print(wif,end="\r")
                            last_addr = addr
                            break

                    except Exception as e:
                        print(f"[!] Erro ao gerar chave no pulo de {percentual_de_pulo}%: {e}")

                    attempts += 1
 
            else:
                print(wif)
                last_addr = addr

            if addr in known_addresses:
                with open("enderecos_encontrados.txt", "a") as f:
                    f.write(f"WIF: {wif} | Address: {addr}\n")
                print(f"\n>>> Endereço {addr} encontrado em gen {gen}!\n")
                #break

        score, addr, secret, wif = get_best_info(best, target)
        print(f"-> Final: Generation={gen}, Score={score}, Addr={addr}, WIF={wif}")

if __name__ == "__main__": 

    for TARGET_LEN in range(2, 257):  # de 2 até 256 inclusive
        run_genetic(TARGET_LEN, data_address)
